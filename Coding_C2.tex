\newpage
\begin{center}
  \huge{Codierungstheorie}
\end{center}

\section{Grundbegriffe und einfache Beispiele}
  \subsection{Codierung (Kanalcodierung)}
    \includegraphics[width=\textwidth]{eps/pic02.eps}
    Ziele:
    \begin{itemize}
      \item Sicherung von Daten bei der Übertragung / Speicherung gegen
      Störungen, Fehler, etc.
      \item Möglichst viele Fehler erkennen und gegebenfalls korrigieren.
      \item Aufwand für Codierung und Decodierung soll nicht zu hoch sein.
    \end{itemize}
    Grundprinzip: Hinzufügen systematischer Redundanz.\\
    Fehlererkennung: Geringe Redundanz
    Fehlerkorrektur: Größere Redundanz, größerer Aufwand
  \subsection{Beispiele}
    \begin{enumerate}[a)]
      \item Parity- Check- Code
        $R=\lrc{0,1}$\\
        Nachricht wird in Blöcke von Länge $k$ zerlegt. Füge an jeden Block Bit
        an, so dass die Anzahl der Einsen im Block der Länge $k+1$ gerade ist
        (also 1 für ungerade, 0 für gerade).\\
        $k=2$:\\
        $00\rightarrow000\\
        01\rightarrow011\\
        10\rightarrow101\\
        11\rightarrow110$\\
        1 Fehler wird erkannt (kann nicht korrigiert werden). 2 Fehler können
        nicht erkannt werden.
      \item Wiederholungscode: Nachricht zerlegt in Blöcke der Länge $k$. Jeder
        Block wird $m$ mal gesendet. $k=2$, $m=3$\\
        $01\rightarrow000000\\
        01\rightarrow010101\\
        10\rightarrow101010\\
        11\rightarrow111111$\\
        1 Fehler lässt sich korrigieren.
      \item Codiere Blöcke der Länge 2 wiefolgt:\\
        $00\rightarrow00000\\
        01\rightarrow01101\\
        10\rightarrow10110\\
        11\rightarrow11011$\\
        1- Fehler- korrigierend:\\
        Decodierung: Such das \gqm{nächste} Codeword zum empfangenen Wort. Je
        zwei Codewörter unterscheiden sich an mindestens 3 Stellen.\\
        2- Fehler- erkennend: Kann jedoch nicht korrigiert werden, da Abstand
        zu zwei gültigen Worten 2 ist.
    \end{enumerate}
  \subsection{GTIN- Prüfzifferncode (GTIN-13)}
    \begin{enumerate}[a)]
      \item GTIN=Global Trade Item Number (früher EAN-13)\\
        12- stelliger Code, $R=S=\lrc{0,...,9}$. Erste 12 Ziffern ensprechen
        Information, 13. Ziffer ist die Prüfziffer\\
        $c_1...c_{13}:c_1...c_{12}$\\
        Herstellungsland (in der Regel die ersten drei Ziffern, Deutschland:
        400-440)\\
        Hersteller (in der Regel $c_4,...,c_8$ (4-6 Ziffern)\\
        Produkt (in der Regel $c_9,...,c_{12}$ (3-5 Ziffern)\\
        $c_{13}$ wird so gewählt, dass gilt:
        $c_1+3c_2+c_3+3c_4+...+c_{11}+3c_{12}+c_{13}\equiv 0(\mod 10)$\\
        $c_{13}=(-c_1+3c_2-c_3-...-3c_12)\mod 10$\\
        Änderung einer Ziffer wird erkannt. $x\mapsto 3x\mod 10$ ist bijektiv
        ($\ggT(3,10)=1$)
      \item Übersetzung der GTIN- 13 in Barcode:\\
        Exkurs, spar ich mir.
    \end{enumerate}

\section{Blockcodes}
	\subsection{Definition}
		$S$ endliche Menge (Alphabet), $n\in\mn$\\
		\textbf{Blockcode} $\mathcal{C}$ der \textbf{(Block-)Länge} $n$ über $S$ ist Teilmenge von $S^n=S\underbrace{\times\dots\times}_{n}S$.\\
		Elemente von $\mathcal{C}$: \textbf{Codewörter}\\
		$S=\lrc{0,1}$: \textbf{binärer Blockcode}\\
		Klar ist $\lrabs{\mathcal{C}}\leq\lrabs{S^n}=\lrabs{S}^n$\\
		Ist $\lrabs{\mathcal{C}}=m$, so lassen sich $m$ Informationssymbole (oder Blöcke) durch je ein Codewort coieren.
	
	\subsection{Definition}
		$S$ endliches Alphabet, $n\in\mn$\\
		$a=\lrr{S_1,\dots,S_n}, b=\lrr{t_1,\dots,t_n}\in S^n$\\
		$d\lrr{a,b}=\lrabs{\lrc{i:1\leq i\leq n, s_i\neq t_i}}$ \textbf{Hamming-Abstand} von $a$ und $b$\\
		(R.W. Hamming, 1915-1998; C. Shannon)
		
	\subsection{Bemerkung}
		\subExBegin{a)}
			\item $a,b,c\in S^n \Rightarrow d\lrr{a,c}\leq d\lrr{a,b}+d\lrr{b,c}$ (Dreiecksungleichung)
			
				$a=\lrr{a_1,\dots,a_n}, b=\lrr{b_1,\dots,b_n}, c=\lrr{c_1,\dots,c_n}$\\
				$\Rightarrow a_i\neq c_i\Rightarrow a_i\neq b_i$ oder $c_i\neq b_i$
			\item Ist $S$ abelsche Gruppe (bzgl. $+$), so gilt\\
				$\forall a,b,c\in S^n: d\lrr{a,b}=d\lrr{a+c,b+c}$\\
				$\lrr{a_1,\dots,a_n}+\lrr{c_1,\dots,c_n}:=\lrr{a_1+c_1,\dots, a_n+c_n}$
			\item Wird $x\in\mathcal{C}$ gesendet und $y\in S^n$ empfangen und $d\lrr{x,y}=k$, so sind $k$ Fehler aufgetreten.
		\subExEnd
		
	\subsection{Definition}
		\subExBegin{a)}
			\item \textbf{Hamming-Decodierung} für Blockcode $\mathcal{C}\mpo S^n$
			
				Wird $y\in S^n$ empfangen, so wird $y$ als ein $x'\in\mathcal{C}$ decodiert mit $d\lrr{x',y}=\min\lrc{d\lrr{x,y}:x\in\mathcal{C}}$ (nicht notwendig eindeutig!)\\
				Hamming-Decodierung ist bestmöglich, wenn alle Codewörter mit der gleichen Wahrscheinlichkeit $p<\frac{1}{2}$ gestört werden und wenn jedes Codewort gleich wahrscheinlich ist.
			\item $\mathcal{C}$ Blockcode in $S^n$, $\lrabs{\mathcal{C}}>1$\\
				\textbf{Minimalabstand} $d\lrr{\mathcal{C}}$ von $\mathcal{C}$: $d\lrr{\mathcal{C}}=\min\lrc{d\lrr{x,y}:x,y\in\mathcal{C} x\neq y}$
			\item Blockcode $\mathcal{C}$ heißt \textbf{t-Fehler-korrigierend}, falls $d\lrr{\mathcal{C}}\geq 2t+1$, $\mathcal{C}$ heißt \textbf{t-Fehler-erkennend}, falls $d\lrr{\mathcal{C}}\geq t+1$
		\subExEnd
		
	\subsection{Bemerkung}
		\subExBegin{a)}
			\item Ist $d\lrr{\mathcal{C}}\geq 2t+1$, so sind die \gqm{Kugeln} vom Radius $t$ um Codewörter $x\in\mathcal{C}$, $K_t\lrr{x}=\lrc{y\in S^n: d\lrr{x,y}\leq t}$, sind disjunkt.
			
				Angenommen $x\in\mathcal{C}$ wird gesendet, $y\in S^n$ wird empfangen, maximal $t$ Fehler seien aufgetreten. $d\lrr{x,y}\leq t$ Bei Hamming-Decodierung wird dann $y$ wieder zu $x$ decodiert, denn jedes andere $x'\in\mathcal{C}$ hat Abstand $>t$ von $y$.
				
			\item Ist $d\lrr{\mathcal{C}}\geq t+1$, $x\in\mathcal{C}$ wird gesendet, $y\in S^n$ empfangen, max. $t$ Fehler seien aufgetreten.\\
				$d\lrr{x,y}\leq t$. Also ist $y\notin\mathcal{C}$ (falls mindestens ein Fehler aufgtreten ist.
		\subExEnd
		
	\subsection{Beispiele}
		\subExBegin{a)}
			\item Parity-Check-Code\\
				$\mathcal{C}=\lrc{\lrr{c_1,\dots,c_n}:c_i\in\mz^2,\sum c_i\equiv 0\lrr{\mbox{mod }2}}$\\
				$d\lrr{\mathcal{C}}=2$\\
				$\lrr{c_1,\dots,c_{n-2},c_{n-1},c_n}\in\mathcal{C}$\\
				$\lrr{c_1,\dots,c_{n-2},\overline{c_{n-1}},\overline{c_n}}\in\mathcal{C}$\\
				$\Rightarrow\mathcal{C}$ ist $1$-Fehler-erkennend.
			\item $m$-facher-Wiederholungscode: $d\lrr{\mathcal{C}}=m$\\
				$\mathcal{C}=\lrc{\lrr{0,\dots,0},\lrr{1,\dots,1},\lrr{2,\dots,2},\dots}$\\
				$\mathcal{C}$ ist $\floor{\frac{m-1}{2}}$-Fehler-korrigierend.\\
				$d\lrr{\mathcal{C}}\geq 2t+1$ Für alle $x,x'\in \mathcal{C}, x\neq x': K_t\lrr{x}\mand K_t\lrr{x'}=\mvoid$
		\subExEnd
		
	\subsection{Definition}
		Sei $\mathcal{C}$ Blockcode über $S$ der Länge $n$.\\
		$\mathcal{C}$ heißt \textbf{perfekt}, falls es $t\in\mn_0$ gibt mit $S^n=\ouset{\mor}{\bullet}{x\in\mathcal{C}}K_t\lrr{x}$ (disjunkte Vereinigung)
	
	\subsection{Bemerkung}
		Ist $ \mathcal{C} $ perfekt, $ \lrabs{\mathcal{C}}>1 $, $ t $ wie in 8.7, dann ist $ d(\mathcal{C})=2t+1 $.
		
		\textbf{Beweis:} Klar: $ d(\mathcal{C})>t $. Angenommen, $ d(\mathcal{C})\leq $. Wähle $ x,x'\in\mathcal{C} $ mit $ d(x,x')=d(\mathcal{C}) $. Wähle $ y\in S^n $ mit $ d(x,y)=t,\ d'(x',y)\leq t $\\
		Dann; $ x\in K_t(x)\mand K_t(x') $ \lightning.\\
		Also $ d(\mathcal{C})\geq 2t+1 $\\
		Wähle $ x\in\mathcal{C} $. Wähle $ y\in S^n $ mit $ d(x,y)=t+1 $. $ y\notin K_t(x) $. $ \mathcal{C} $ perfekt. $ \exists x'\in\mathcal{C} $ mit $ y\in K_t(x') $. $ d(x,x')\leq d(x,y)+d(y,x') \leq t+1+t=2t+1 $\\
		Also: $ d(\mathcal{C})\geq 2t+1 $
		
	\subsection{Lemma}
		$ \lrabs{S}=q $, $ x_t\in S^n $, $ t\in\mn_0 $. Dann ist $ \lrabs{K_t(x)}=\limsum{i=0}{t}\binom{n}{i}(q-1)^i $
		
		\textbf{Beweis:} $ x\in S^n $. Wie viele Wörter haben Abstand $ i $ von $ x $?\\
		Wähle $ i $ Positionen aus $ \lrc{i,...,n} $ aus: $ \binom{n}{i} $ Möglichkeiten.
		Bei Auswahl dieser Positionen: $ (q-1)^i $ Möglichkeiten, ein Wort auszuwählen, dass sich von $ x $ an diesen $ i' $ Positionen unterscheidet.\\
		gibt es insgesamt $ \binom{n}{i}(q-1)^i $ Wörter, die den Abstand $ i $ haben. In einer Kugel müssen diese noch aufsummiert werden.
		
	\subsection{Satz}
		Sei $ \mathcal{C} $ ein Code der Länge $ n $ über $ S $, $ \lrabs{\mathcal{C}}=1 $, $ \lrabs{S}=q $. Sei $ t\in\mn_0 $ maximal mit $ d(\mathcal{C})\geq 2t+1 $, d.h. $ t=\lfloor\frac{d(\mathcal{C}) -1}{2}\rfloor $.
		\begin{enumerate}[a)]
			\item  Hamming- Schranke, Kugelpackungsraum $ K_0 $.
			\[\lrabs{\mathcal{C}}=\dfrac{q^n}{\limsum{i=0}{t}\binom{n}{i}(q-1)^i}\]
			\item  $ \mathcal{C} $ ist perfekt $ \Leftrightarrow $ in a) gilt Gleichheit.
		\end{enumerate}
		
		\textbf{Beweis:}
		\begin{enumerate}[a)]
			\item $ S^n\mpo\bigcup\limits_{x\in\mathcal{C}}^{\cdot} K_t(x)\ \Rightarrow\ q^n=\lrabs{S^n}\geq\lrabs{\bigcup\limits_{x\in\mathcal{C}}^{\cdot}K_t(x)}=\limsum{x\in\mathcal{C}}{}\lrabs{K_t(x)}\ouset{=}{}{\mbox{\scriptsize 8.9}}\mathcal{C}\cdot\limsum{i=0}{t}\binom{n}{i}(q-1)^i $.
			\item  Gleichheit:\\
			$ \leftrightarrow S^n=\bigcup\limits_{x\in C}^{\cdot}K_t(x)\ \Leftrightarrow\ C $ perfekt.
		\end{enumerate}
	
	\subsection{Beispiel}
		Skip
		
	\subsection{Beispiele für perfekte Codes}
		a) - c) trivial perfekte Codes
		\begin{enumerate}[a)]
			\item Einelementige Codes ($ t=n $)
			\item $ \mathcal{C}=S^n\quad (t=0) $
			\item  $ n=2t+1 $, $ \mathcal{C}=\lrc{(0,...,0),(1,...,1)} $ perfekt
			\item $ S=\mz_2=\lrc{0,1} $\\
			$ \mathcal{C}=\lrc{(c_1,...,c_7)\in\mz_2^7:c_1+c_4+c_6+c_7=0,\ c_2+c_4+c_5+c_7=0,\ c_3+c_5+c_6+c_7} $\\
			$ \lrabs{\mathcal{C}}=2^4,\ d(\mathcal{C})=3 $ (nachrechnen)\\
			\textbf{links:} $ \lrabs{\mathcal{C}}=2^4 $\\
			\textbf{rechts:} $ \frac{2^7}{1+7}=2^4 $\\
			\textbf{Hamming- Code}
		\end{enumerate}
		
\section{Lineare Codes}
	\subsection{Definition}
		$ K $ endlicher Körper, $ n\in\mn $.\\
		Ein \textbf{linearer Code} $ \mathcal{C} $ ist ein Unterraum des Vektorraums $ K^n $ (d.h. Alph$ =k $).\\
		Ist $ \dim(\mathcal{C})=k(\leq m) $, so heißt $ \mathcal{C} $ ein $ [n,k] $- Code.\\
		Ist $ \lrabs{K}=q $, $ \dim(\mathcal{C})=k $, dann $ \lrabs{\mathcal{C}}=q^k $.\\
		$ \mathcal{C} $ hat Basis $ w_1,...,w_k $, $ \mathcal{C}=\lrc{a_1w_1+...+a_kw_k:\ a_i\in K} $
	
	\subsection{Bemerkung}
		$ \mz_p={0,...,p-1} $ ist Körper bezüglich Addition und Multiplikation $ \mod p $, falls $ p $ eine Primzahl ist.\\
		Körper von Ordnung $ p^m $: Irreduzibles Polynom $ g $ vom Grad $ m $ über $ \mz_p $.\\
		$ K=\lrc{f\in\mz_p[x]:\grad(f)<m} $, $ \lrabs{K}=p^m $\\
		Addition und Multiplikation $ \mod g $.\\
		(Bis auf Isomorphie) gibt es keine anderen endlichen Körper.
		
	\subsection{Beispiel}
		\subExBegin{a)}
		\item $ n $- facher Wiederholungscode über $ \mz_p $.\\
		$ \mathcal{C}=\lrc{(0,...,0),(1,...,1),...,(p-1,...,p-1)}=\lrg{(1,...,1)} $ $ [1,n] $- Coder über $ \mz_p $.\\
		$ d(\mathcal{C})=n $
		\item Hamming- Code (8.12 d)) ist \textbf{linearer} $ [4,7] $- Code über $ \mz_2 $, $ d(\mathcal{C})=3 $ (als Lösungsraum eines homogenen, linearen LGS über $ \mz_2 $).
		\item $ n\geq 2 $. $ \mathcal{C}=\lrc{(c_1,...,c_n):\ \limsum{i=1}{n}c_i=0}\mpo K^n $ linearer $ [n-1,n] $- Code.\\
		$ K=\mz_2 $: Parity- Check- Code
		\subExEnd
		
	\subsection{Definition}
		$ K $ endlicher Körper.
		\begin{enumerate}[a)]
			\item $ x= (x_1,...,x_n)\in K^n$. $ wt(x)=d(x,0)=\lrabs{\lrc{i:\ x_i\neq 0}} $ Gewicht von $ x $.
			\item Ist $ \lrc{0}\neq\mathcal{C}\mpo K^n $, so heißt $ wt(\mathcal{C})=\min\lrc{wt(x):\ 0\neq x\in\mathcal{C}} $\\
			Minimalgewicht von $ \mathcal{C} $.
		\end{enumerate}
		
	\subsection{Satz}
		Ist $ \lrc{0}\neq\mathcal{C} $ ein linearer Vode, so ist $ d(\mathcal{C})=wt(\mathcal{C}) $.
		
		\textbf{Beweis:} $ \mathcal{C} $ linear, $ x,x'\in\mathcal{C}\ \Rightarrow\ x-x'\in\mathcal{C} $.\\
		$ d(\mathcal{C})=\min\lrc{d(x,x'):\ x,x'\in\mathcal{C},\ x\neq x'} $\\
		$ =\min\lrc{d(\underbrace{x-x'}_{\in\mathcal{C}},0):\ x,x'\in\mathcal{C},\ x\neq x'} $\\
		$ =\min\lrc{d(y,0):\  \neq y\in\mathcal{C}}=wt(\mathcal{C}) $.